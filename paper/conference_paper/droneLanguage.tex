\documentclass{sig-alternate-05-2015}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{cite}
\usepackage[override]{cmtt}
\usepackage[inline]{enumitem}
\usepackage[draft]{hyperref}
\usepackage{microtype}
\usepackage{color}

\usepackage{lambda}
\renewcommand{\progfontsize}{\normalsize}
\usepackage{listings}

\lstset{
  language=Haskell,
  showstringspaces=false,
  basicstyle=\ttfamily\scriptsize %\bfseries
}

\begin{document}

\setcopyright{acmcopyright}


% \doi{10.475/123_4}
% \isbn{123-4567-24-567/08/06}

\conferenceinfo{IFL '16}{Aug 31--Sept 2, 2016, KU Leuven, Belgium}
% \acmPrice{\$15.00}
% \conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}

\title{A DSL for Mixed-Initaitive Drone Control}
% \subtitle{[Extended Abstract]}
% \titlenote{A full version of this paper is available as
% \textit{Author's Guide to Preparing ACM SIG Proceedings Using
% \LaTeX$2_\epsilon$\ and BibTeX} at
% \texttt{www.acm.org/eaddress.htm}}}

\numberofauthors{2}
\author{
% 1st. author
\alignauthor
Keeley Abbott\\
\affaddr{School of EECS
\\ Oregon State University \\ Corvallis, OR, USA}\\
\email{abbottk@oregonstate.edu}
% 2nd. author
\alignauthor
Eric Walkingshaw\\
\affaddr{School of EECS
\\ Oregon State University \\ Corvallis, OR, USA}\\
\email{walkiner@oregonstate.edu}
}

\maketitle
\begin{abstract}
%
We present a domain-specific language embedded in Haskell for writing
mixed-initiative programs to pilot semi-autono\-mous drones. The main novelty of
our language is that it supports a flexible exchange of control flow between a
pre-programmed auto-pilot and a human pilot with manual flight controls. From
the DSL programmer's perspective, this exchange is managed by a small set of
primitives for (synchronously or asynchronously) negotiating initiative. From
the human pilot's perspective, it is supported by an architecture that
organizes the program into understandable units organized in a simple control
flow with contingencies. The design of the high-level architecture is based on
a formative study of lab protocols, which are effectively programs that must be
understood and executed by other people.
%
Our language runtime is implemented using functional reactive programming.
%
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003120.10003121.10003124.10011751</concept_id>
<concept_desc>Human-centered computing~Collaborative interaction</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003120.10003121.10003122.10003332</concept_id>
<concept_desc>Human-centered computing~User models</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003120.10003123.10010860.10010911</concept_id>
<concept_desc>Human-centered computing~Participatory design</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
<concept_desc>Software and its engineering~Functional languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011050.10011054</concept_id>
<concept_desc>Software and its engineering~Command and control languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10010940.10010971.10011679</concept_id>
<concept_desc>Software and its engineering~Real-time systems software</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Human-centered computing~Collaborative interaction}
\ccsdesc[300]{Human-centered computing~User models}
\ccsdesc[300]{Human-centered computing~Participatory design}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Command and control languages}
\ccsdesc[300]{Software and its engineering~Real-time systems software}

\printccsdesc

\keywords{}

\section{Introduction}
\label{sec:intro}

The consumer and industrial market for unmanned aircraft systems (drones) has
exploded in recent years, with the Federal Aviation Administration estimating
that 2.5 million drones will be sold in 2016 in the United States alone
\cite{FAA16fore}. These vehicles have a wide range of commercial, industrial, and
scientific applications.

Drones are also an ideal platform for exploring \emph{mixed-initiative
computing}~\cite{H99principles}---a model of computation in which human agents
and software agents negotiate control of a process and collaborate to solve a
problem.
%
Current consumer drone software is already mixed-initiative (usually called
semi-autonomous, in this context) since aspects of a single flight might be
controlled remotely by a human pilot and others by an on-board computer. For
example, a pilot might use a remote control to move a drone around and take
pictures, while the on-board computer makes stability adjustments, implements a
stationary hover, and automatically returns to its starting point if it loses
contact with the pilot.

Unfortunately, the majority of programs written for drones are written in
low-level languages like \prog{C}. This makes it difficult to express more
sophisticated interactions between the human pilot and the on-board computer,
and also limits potential drone programmers to experts in embedded systems.

In this paper, we present a domain-specific language embedded in Haskell for
writing mixed-initiative flight control programs for drones. The practical goal
of this language is to raise the level of abstraction for drone programming,
increasing its accessibility and making feasible new kinds of drone programs
that better exploit the strengths of both the human and computer actors in this
mixed-initiative setting.

We are also interested in mixed-initiative computing in general. Previously, we
conducted a formative study of how people write programs (in the form of lab
protocols) for other people to execute. From this study, we extracted design
insights to best support the human agent in a mixed-initiative
setting~\cite{ABW15prog}.
%
Therefore, a higher-level goal of this work is to put these design insights to
practice, evaluating whether they are actionable and lead to a useful language
design.

Our DSL is implemented using functional reactive programming (FRP), a
functional programming model based on time-varying behaviors and
events~\cite{EH97fra,WH00frp}.

The specific contributions of this work are therefore both: (1) the \emph{DSL
itself}, a high-level declarative language for a rapidly emerging application
domain, and (2) a new \emph{programming model} for mixed-initiative computing
that supports sophisticated negotiation of control between human and computer
agents.

\subsection{Mixed-Initiative Computing}
\label{sec:intro:mic}

The fundamental promise of mixed-initiative computing is that humans and
computers have complementary strengths and weaknesses, and so together can
solve problems more effectively than either could alone.
%
Within the application domain of semi-automated drones (and also more
generally), computers excel at executing repetitive strategies, performing
rapid calculations, monitoring many sensors at once, and executing precise
adjustments. Meanwhile, humans excel at visual recognition, recovering from
errors, providing high-level oversight, and revising plans in in the presence
of unforeseen events.

The goal of our DSL is to allow programmers to take advantage of these
complementary strengths. For example, in fully autonomous situations, planning
for contingencies is a tedious, error-prone, and often incomplete process. A
mixed-initiative program can instead simply transfer control to the human in
such an event, relying on their judgment and creativity to recover.
%
In our previous work on lab-protocols, we found that when people write complex
instructions (programs) for other people to execute, they often provide only
high-level checks to ensure that the person executing the program is still on
the right track, and leave it up to them to recover,
otherwise~\cite{ABW15prog}.

At a higher level, consider a program for either surveying territory or
conducting a search-and-rescue operations, which are real-world tasks that
employ drones and exemplify how the strengths of human and computer actors can
complement each other in a mixed-initiative program. Such a program might have
the drone automatically traverse an area while the human monitors camera output
for potential objects of interest, taking over manual control when one is
found. If, upon closer investigation, the object is not of interest, the human
can return control to the auto-pilot to resume traversing the area. The
computer can monitor other sensors (such as proximity and battery), and notify
the human of significant events. The human can help the drone react to
unforeseen circumstances and also adjust the high-level parameters of the
search (e.g.\ expanding or shrinking it) to incorporate new external
information, as needed.

In our study of lab protocols~\cite{ABW15prog}, we have identified several
unique aspects of programs written for people compared to programs written for
computers, and have used related work on how humans \emph{use} plans and
protocols~\cite{S87plans,L02protocols} to argue that these differences make
sense given the respective strengths and weaknesses of humans and computers.
%
We believe that a mixed-initiative programming language will be most useful if
it takes both kinds of agents into account.
%
Some distinguishing features of programs for people is that they achieve
flexibility, reusability, and robustness through \emph{simplicity}. The idea is
that, to execute a plan and adapt it to new situations, a person should be able
to understand how it works in its entirety. From this perspective, explicit
error handling actually detracts from the utility of a program since it makes
it more difficult to understand; it is better to rely on human judgment for
robustness. Similarly, programs for people are mostly linear with minimal
branching, looping, or other complex control flow.
%
However, human protocols support a rather sophisticated form of composition by
using common sense to interleave multiple protocols. This can be used in many
scenarios where a computer program would use conditionals, for example, to
interleave certain safety measures only when handling certain kinds of
dangerous materials.

% In this paper we introduce an embedded domain-specific language that is
% functionally reactive and allows for the interleaving of human actor
% directives, with those supplied by the programmer. It also allows for timed or
% event based interventions or triggers for further program execution. This
% provides a degree of variability within drone programming that takes into
% account the most up-to-date information and directives as supplied by the
% human actor, while allowing for automation of the process whenever outside
% intervention is unnecessary.

% Human actors have been used to identify visual patterns as well as in aerial
% search activities in the form of crowd-sourcing applications
% \cite{QB11comp}. Often these tasks come in the form of games, or provide
% some monetary compensation for the user's time in classifying or searching
% images for data. Frameworks for distributing these tasks to the crowd have
% also been developed to assist programmers in developing their queries and
% honing them through successive collections of data obtained from the crowd
% \cite{LCGM10turkit}.

% One difficulty that is often encountered when using crowd-sourcing for the
% purposes of surveying or search and rescue, is that the queries often take a
% long time to return results. Which can degrade the chances of a successful
% outcome, and can result in the use of outdated information when reacting to
% data collected from participants. To some extent this can be mitigated with
% the use of increased monetary incentives to the crowd participants. In
% addition to timing issues, crowd-sourcing applications often treat humans as
% monetized data processing labor, and fail to take advantage of the crowd's
% facilities beyond visual pattern matching.

% In MICL, we allow the human actor to directly interact with and manipulate the
% flow of control and the expected outcomes in real time. This provides the
% benefit of making new information gathered by the human actor's visual pattern
% matching skills more readily available in addition to allowing us to take
% advantage of the human actor's skills and knowledge that may supersede that of
% the original goals or programming.


% \subsection{Contributions}
% \label{sec:intro:contr}
% The contributions of this work are as follows:
%
% In many cases, once a program is generated for a semi-autonomous vehicle or
% device, there is little question of what is \emph{done} with that program once
% it has been written by the programmer. Our approach allows the human actor to
% provide additional insight based on previous experience or current
% circumstances that may not have been considered by the programmer.
%
% Our approach in MICL is to provide a set of descriptive, strongly typed and
% composable language features. The features are such that the type of the
% resulting execution is evident in the provided features. We provide examples
% of executing the language and show the simulation of moves performed by the
% system, as well as those performed by the human actor.
%
% MICL is an \emph{embedded domain-specific language} within Haskell that
% presents a way for programmers to design mixed-initiative controller programs
% that are strongly typed. Type information for these programs is preserved,
% making it easy to ``stitch'' together existing processes into a larger flow
% for programs, as well as modify the order of events without harming the
% integrity of the overall system-provided goals.

% \TODO{Functional Reactive Programming Section}

\subsection{Functional Reactive Programming (FRP)}
\label{sec:intro:frp}

Functional Reactive Programming (FRP)~\cite{H00haskell,WH00frp} is a
high-level declarative language implemented in Haskell~\cite{Hea92report} for
the purpose of programming reactive systems. \emph{Reactive systems} process
and react to external input throughout execution.

The two fundamental types in FRP are the \prog{Behavior} and \prog{Event}
types. Behaviors represent values that are reactions to events, and can be
viewed as a stream that can change over continuous time. In turn FRP programs
can be thought of as stream transformers. In other words FRP programs are
\emph{reactions} to the current state of the system. Events are time-ordered
sequences of discrete event occurrences. These can include events such as
discreet button or keyboard presses, and represent the entire \emph{sequence}
of events of the respective type as opposed to individual event instances of
that type.

The reactive nature of FRP lends itself to application in domains such as
interactive computer animation~\cite{EH97functional}, graphical interface
design~\cite{CE01genuinely}, computer vision~\cite{RPHH99prototyping},
robotics~\cite{PHH99language}, and control systems~\cite{WTH02event}.

In our DSL the goal is to provide programmers with the constructs necessary to
accommodate exactly this type of reactive programming. We can then take
advantage of the strengths of both human and computers as described in
section~\ref{sec:intro:mic}. FRP programs can easily negotiate the transfer of
control between the human and the system, while providing the high-level
checks expected in programs written for people. In this way the programmer can
avoid unnecessary error checking by leaving it to the user to recover when
possible, while providing guidelines for making progress.

Returning to the higher level example of programs for surveying territory or
conducting a search-and-rescue operations. A program written for either of
these purposes can be fairly easily divided into tasks and assigned to the
user or the system as described in section~\ref{sec:intro:mic}. In order to
accommodate the switching described the user is provided with a manual set of
controls, whose events and behaviors can be monitored, and when key events
or behaviors are observed allow the system to react to the changed state.

\subsection{Multi-Agent Systems}
\label{sec:intro:mas}

\section{Language Overview}
\label{sec:lang}

In this section we provide an overview of unique aspects of the DSL, as well
as a complete description of its technical functionality.

The main design goal of our DSL is to support a flexible exchange of control
between the computer and human agents in our mixed-initiative setting. At a
low-level this is supported through four basic \emph{primitives for negotiating
control}. Although both agents are always acting in parallel, one can imagine
``control'' as token that is passed between the two agents; whoever has the
token has exclusive access to certain functionality, such as moving the drone.
%
\begin{itemize}
%
\item \textbf{Give}: Executed by the agent with the token to transfer it to the
other agent. When the computer gives control to the human, it should provide a
reason for the transfer and any information needed for the human to decide and
act. When the human gives control to the computer, it should specify where in
the program to resume executing.
%
\item \textbf{Offer}: Executed by the agent with the token to offer a transfer
of control to the other agent, which the second agent may refuse.
%
\item \textbf{Request}: Dual to offer; executed by the agent without the token
to request it from the currently in-control agent, which the in-control agent
may refuse.
%
\item \textbf{Take}: Dual to give; executed by the agent without the token to
immediately take it from the in-control agent.
%
\end{itemize}
%
To minimize the overhead of control negotiation for the human (e.g.\ minimize
annoying dialogs), offers and requests are asynchronous. That is, an offer of
control from agent A to agent B will succeed if B has made a request since A's
last offer, otherwise the runtime system assumes the offer is declined.
%
A synchronous offer can be made by giving control and then optionally giving
control back.

\section{Motivating Example}
\label{sec:example}

\TODO{Motivating example -- extended example of a search-and-rescue or
territorial surveying program}

% For example, a programmer codes a drone to use a flight pattern to perform
% a search within a prescribed area or boundary, and in addition provides the
% human actor with an intended search target and/or some set of goal-directed
% tasks that need to be accomplished. We know from previous research
% \cite{ABW15prog} that users adopt human instructions or programs more
% readily when they are supplied in a linear fashion (giving the user a
% high-level overview of the process). These instruction sets also need to
% provide users with derivation points that allow them the freedom to modify
% instructions as needed, while simultaneously providing guideposts for error
% recovery and locations to return to the original protocol.

% \begin{lstlisting}[breaklines=true]
% give = \p $\arrow$ catchError p give
% \end{lstlisting}

% In this example, the programmer is able to use the predefined \prog{takeOff}
% program that (when supplied with a ceiling -- or \prog{down} parameter) causes
% the drone to lift off from the ground at the current spot, and accelerate
% upwards until it reaches the ceiling value. The \prog{grid} constructor
% supplies \prog{takeOff} with the necessary ceiling parameter, but also
% outlines a search grid for the drone (essentially a 100 meter by 100 meter
% square).

% \prog{pattern} tells the drone how to cover the prescribed grid, and
% \prog{radial (2 m)} tells the drone to radiate from a given point circling
% 2 meters from the previous path with each pass. \prog{fromCenter} is used in
% an ``inline'' fashion for convenience sake, and instructs the drone to begin
% the indicated pattern from the center of the prescribed grid. Which means that
% once the drone takes off, it will fly to the center of the grid, and works
% it's way to the edges using the radial pattern described.

% \prog{instructions} provide some tasks for the human actor to complete, and
% are goal-directed in nature. These tasks provide the user some end goal they
% need to reach (as well as some potential guidance if the user encounters
% trouble or diverges from the initial path), but does not specify for the user
% how to complete that goal. Some informational text is provided to the user via
% the user interface at the start of the search, and there are guideposts for
% the user to follow to ensure they are on the correct path as well.

% \begin{lstlisting}
% searchText :: Interface
% searchText = (information
%               [("tag squirrels",
%                 "create a new waypoint"),
%                ("suggest new search quadrant",
%                 "use waypoint to re-center quadrant,
%                  or specify new home location"),
%                ("return drone home",
%                 "manually fly the drone back to the
%                  home location, or specify new home
%                  location with waypoint")
%                ])
% \end{lstlisting}

\section{Results}
\label{sec:results}

\TODO{Results section -- something having to do with not being able to have
deadlock issues in the negotiation process.}

\section{Related Work}
\label{sec:related}

In Section~\ref{sec:intro}, we mentioned that the majority of programs for
drones are written in low-level languages like \prog{C}. There is language
support for writing \prog{safe-C} code available, however there has not been
much work on providing support for expressing sophisticated interactions
between the human-pilot and the on-board computer. The closeness of mapping
between many of the libraries available in Haskell and the \prog{C} language
they compile to also limits the pool of available drone programmers to those
who are either experts in the domain, or those who have invested time in
specializing their programming knowledge.

\TODO{Planned negotiated programming (PNP)} is a formal language for
representing high-level interactions between the human pilot and the on-board
computer, and is the basis for the mixed-initiative drone control language as
well as the programming model we present.

Researchers have called for more flexible flows of control between people and
computers~\cite{L60symbiosis} as early as 1960. The explicit interleaving
of human and computer tasks through hardwiring (e.g.~\cite{LHML08cosripter}),
allowing machine learning searches to be interactively shaped by human users
through the addition of constraints
(e.g.~\cite{LMRS04symbiosis},~\cite{Kea11why}), and discourse-based techniques
(e.g.~\cite{SRL01collagen},~\cite{ML92explanatory}) are all mechanisms for
trading initiative that have been explored in the past. This prior work has
focused on implementing or improving mixed-initiative programs, however our
work focuses on applying language features behind programs written for people
to mixed-initiative programming.

Languages and libraries also exist within Haskell for compiling or writing
\prog{safe-C} code, such as Ivory~\cite{Eea15ivory}, and
CoPilot~\cite{PGMN10copilot}. Both of these languages are designed to be
used with controllers, and have been used to write drone programs by compiling
\prog{safe-C} code from Haskell that can be run directly on current controller
hardware.

Ivory has been used to implement code that can be run directly on Ardupilot
hardware, and has been used to generate over 200,000 lines of code for
SMACCMPilot~\cite{Hea14build} as well. However, the code generated by
Ivory for use in SMAACMPilot has largely been contributions by the team who
designed the language. In addition though, this language has been used in
Boeing's STANAG486~\cite{B16little} program to pilot an unmanned
helicopter through real-world situations.

% Unfortunately the structure of the language presented by Ivory can be a bit
% difficult to decipher at times owing to its intentional closeness of mapping
% with \prog{C}. In turn this creates a barrier for non-experts in the domain of
% drone controller languages.

The structure of Ivory maps very closely with \prog{C}, and requires the use
of ``structure decorations'' to accomplish this. Although this close
correspondence intentionally evokes \prog{C}, it would be reasonable to assume
this method of implementing Ivory creates some barriers for non-experts
in the domain of drone controller languages.

% Copilot on the other hand is a runtime system that generates streams of small
% constant-space and constant-time \prog{C} programs that implement embedded
% monitoring. Because Copilot also generates its own scheduler, there isn't any
% need to implement a real-time operating system in conjunction with it.

CoPilot is another approach to dealing with \prog{safe-C} programming. This
stream-based dataflow language generates small constant-time and
constant-space \prog{C} programs that implement embedded
monitors. Constant-space programming means that no dynamic memory allocations
are needed. CoPilot periodically samples global variables of the program or
programs; following a sampling-based monitoring strategy. The language itself
provides mechanisms for controlling when to observe the variables.

By using the Atom compiler~\cite{H08controlling} for its back-end, CoPilot can
also automatically generate its own periodic schedule. This negates the need
for a real-time operating system in order to control scheduling and
concurrency, allowing CoPilot to be easily executed on embedded hardware with
minimal system resource availability.

\TODO{Find some examples of Multi-Agent Systems that are comparable to our
DSL.}

Where both of these approaches differ from our DSL, is in the availability and
representation of interactions between the human and the system executing the
program. In our DSL we treat these interactions as first-class citizens,
rather than as an afterthought.

\section{Future Work}
\label{sec:future}



\section{Conclusion}
\label{sec:conclusion}



\bibliographystyle{abbrv}
\bibliography{droneLanguage,protocolStudy}


\end{document}
